#! /usr/bin/env python
# -*- coding: utf-8 -*-

"""Remote jupyter kernel via SSH
Make sure that you can login to a remote machine without entering password.

"""

from getpass import getuser
from json import load
from os import getcwd, remove
from os.path import exists, isfile, join, split
from sys import argv

from execnet import makegateway
from paramiko.util import log_to_file

from rk.ssh import paramiko_tunnel

interpreter = argv[1] # An entry point or an absolute path
        # to language interpreter on a remote machine
local_connection_file = argv[2] # Absolute path of a local connection file
remote_username_at_remote_host = argv[3] # Just a remote host or,
        # if your username is different on a remote machine,
        # use this syntax: remote username AT remote host.

local_username = getuser()
if '@' in remote_username_at_remote_host:
    remote_username, remote_host = remote_username_at_remote_host.split('@')
    if local_username != remote_username:
        # Local username is NOT the same as a remote username
        remote_connection_file = local_connection_file.replace(local_username,
                                                               remote_username)
    else:
        # Local username is the same as a remote username
        remote_connection_file = local_connection_file
        remote_username_at_remote_host = remote_host
else:
    # Local username is the same as a remote username
    remote_connection_file = local_connection_file
# Load a connection file
with open(local_connection_file) as f:
    cfg = load(f)
# GET a current working directory of a process
cwd = getcwd()
# Launch a kernel process on a remote machine
gw = makegateway("ssh=%s//python=%s" % (remote_username_at_remote_host,
                                        interpreter))
ch = gw.remote_exec("""
    import socket
    from IPython import start_kernel
    from json import dumps
    from os import chdir, getcwd
    from os.path import exists, expanduser, isdir, join, split
    from struct import pack

    remote_connection_file = "%s"
    cfg = %s
    last_cwd = "%s"
    remote_ports = {}
    ports = [k for k,v in cfg.items() if k.endswith("_port")]
    # Select random ports
    for port in ports:
        sock = socket.socket()
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_LINGER, pack("ii", 0, 0))
        sock.bind(('', 0)) # Random free port from 1024 to 65535
        sock_name = sock.getsockname()[1]
        remote_ports[port] = sock_name
        cfg[port] = sock_name
        sock.close()
    channel.send(remote_ports)
    if not exists(remote_connection_file):
        dir_name, file_name = split(remote_connection_file)
        if exists(dir_name) and isdir(dir_name):
            # Write a connection file
            with open(remote_connection_file, 'w') as f:
                f.write(dumps(cfg))
        else:
            path = "~/.ipython/profile_default/security"
            default_dir_name = (expanduser(path))
            if ((default_dir_name != dir_name) and exists(default_dir_name) and
                    isdir(default_dir_name)):
                remote_connection_file = join(default_dir_name, file_name)
                # Write a connection file to default directory
                with open(remote_connection_file, 'w') as f:
                    f.write(dumps(cfg))
            else:
                cwd = getcwd()
                remote_connection_file = join(cwd, file_name)
                # Write a connection file to cwd
                with open(remote_connection_file, 'w') as f:
                    f.write(dumps(cfg))
    # SET a current working directory of a process
    if exists(last_cwd) and isdir(last_cwd):
        chdir(last_cwd)
    start_kernel(["-f", remote_connection_file])
                    """ % (remote_connection_file, cfg, cwd))
# Local and remote ports dicts
local_ports = {k: v for k,v in cfg.items() if k.endswith("_port")}
remote_ports = ch.receive()
# Create paramiko log file
dir_name, file_name = split(local_connection_file)
file_name = file_name.replace("kernel", "paramiko")
file_name = file_name.replace(".json", ".txt")
paramiko_log_abs_path = join(dir_name, file_name)
log_to_file(paramiko_log_abs_path)
# Redirect localhost:local_port to remote_host:remote_port
for k,v in local_ports.items():
    paramiko_tunnel(v, remote_ports[k], remote_username_at_remote_host)
# Waits for closing, i.e. remote_exec() finish
ch.waitclose()
# Delete paramiko log file
if exists(paramiko_log_abs_path) and isfile(paramiko_log_abs_path):
    remove(paramiko_log_abs_path)
